<!doctype html><html lang=en-us><head><meta charset=utf-8><title>关于分页(pagination)</title><meta name=description content><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=alternate type=application/rss+xml href=https://blog.isayme.org/index.xml title="BLOG - ISAYME"><meta name=twitter:card content="summary"><meta name=twitter:title content="关于分页(pagination)"><meta name=twitter:description content="列表类的 API 通常需要进行分页处理."><link rel=stylesheet href=https://blog.isayme.org/fontawesome/css/all.min.css><link crossorigin=anonymous href=/css/styles.min.css integrity rel="preload stylesheet" as=style><link rel=stylesheet href=https://blog.isayme.org/css/custom.css><link id=dark-mode-theme crossorigin=anonymous href=/css/dark.min.css integrity rel="preload stylesheet" as=style><script>var darkTheme=document.getElementById('dark-mode-theme')
var storedTheme=localStorage.getItem('dark-mode-storage')
if(storedTheme==='dark'){darkTheme.disabled=false}else if(storedTheme==='light'){darkTheme.disabled=true}</script><script defer crossorigin=anonymous src=/js/theme.js integrity></script><script defer crossorigin=anonymous src=/js/instantpage.min.js integrity></script><meta name=generator content="Hugo 0.78.1"></head><body><header><nav class=navbar><div class=nav><ul class=nav-links></ul></div></nav><div class=intro-header><div class=container><div class=posts-heading><h1>关于分页(pagination)</h1></div></div></div></header><div class=container role=main><article class=article class=blog-post><p>列表类的 API 通常需要进行分页处理.</p><h2 id=方案1-基于-offset-的分页>方案1: 基于 offset 的分页</h2><p>思路是通过 offset 跳过一部分数据, 以获取部分数据. 实际实践中主要由两种风格:</p><ol><li>docs[offset, offset + pageSize]</li><li>docs[(page - 1) * pageSize, page * pageSize]</li></ol><p>其中 offset 也常被称为 skip; pageSize 也常被称为 count / page_count / per_page 等.</p><p>这个策略的优势是简单易懂. 通过参数就可以知道获取的是哪部分数据.</p><p>这个策略存在两大缺陷:</p><ol><li>如果 docs 数据在两次分页请求间发生了变化, 会导致获取到的数据存在重复或丢失情况;</li><li>由于策略的本质是 skip 一部分数据, 当 skip 的值较大时, 存在理论上的性能问题.</li></ol><blockquote><p>具体数据重复/丢失图解: <a href=http://www.scienjus.com/app-server-paging/>APP后端分页设计 · ScienJus’s Blog</a></p></blockquote><h2 id=方案2-基于时间线的分页>方案2: 基于时间线的分页</h2><p>比如按照创建时间排序, 查找指定时间之前的数据: created_before=timestamp</p><p>这个策略的优势是可以利用 创建时间 字段的索引, 避免 skip 数据.</p><p>这个策略存在一大缺陷:</p><ol><li>不同数据的创建实际有可能相同. 这会导致获取到的数据存在丢失情况. 实际实践中会改用不会存在重复值且可以比较大小的字段(如 MongoDB 中的 ObjectId)</li></ol><h2 id=方案3-基于-cursor-的分页>方案3: 基于 cursor 的分页</h2><p>cursor 的本质还是 时间线分页 的思路.</p><p>典型的场景是按照创建时间分页, 由于 MongoDB 的 ObjectId 带有时间值, 且可以比较大小, 所以可以使用 id_before=5bd6d209f81581c9ff3ba00a 这样的方式进行分页.</p><p>如果希望使用 cursor 需要满足三个条件:</p><ol><li>唯一: 不唯一的话会导致查找出的数据有丢失;</li><li>有序: 有序才可以进行比较;</li><li>不可变: 一旦字段数据变化则会影响排序结果;</li></ol><h3 id=如果你在用-mongodb>如果你在用 MongoDB</h3><ul><li><a href=https://docs.mongodb.com/manual/reference/method/cursor.min/>cursor.min()</a> & <a href=https://docs.mongodb.com/manual/reference/method/cursor.max/>cursor.max()</a> 会有所启发.</li><li><a href=https://stackoverflow.com/questions/5525304/how-to-do-pagination-using-range-queries-in-mongodb/5526907#5526907>How to do pagination using range queries in MongoDB?</a></li><li><a href=https://stackoverflow.com/questions/40634865/efficient-paging-in-mongodb-using-mgo>Efficient paging in MongoDB using mgo</a> Golang</li></ul><h2 id=实践-pagetoken>实践: pageToken</h2><p>如果可以使用 cursor 分页, 当然最好了, 但往往很多分页只能使用 offset 分页, 甚至同一个接口的不同排序方式可以采用不同的分页策略, 最终导致 API 分页风格迥异, 对使用方不够友好(传参方式不同).</p><p>所以期望有个方案能够统一调用方分页传参方式, 最终分页策略由服务端决定.</p><p>这个方案就是 pageToken. 这个方案的思路是: 客户获取第一页数据后, 服务端返回一个 pageToken, 客户端使用这个 pageToken 获取第二页数据. 由于 pageToken 由服务端生成, 服务端可以自由利用 pageToken 记录任意信息, 可以依据不同的排序规则记录不同的信息, 最终可以在分页策略上采取最佳的方案.</p><p>然而 pageToken 方案也有一个缺点: 客户端必须一页页获取数据, 无法直接跳到第N页.</p><p>配合 offset 可以解决上面的缺点.</p><h2 id=参考资料>参考资料</h2><ul><li><a href=https://mixmax.com/blog/api-paging-built-the-right-way/>API Paging Built The Right Way</a></li><li><a href=https://cloud.google.com/apis/design/design_patterns#list_pagination>List Pagination</a></li><li><a href=https://www.do1618.com/archives/1157/%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6/>分页机制 - 程序印象</a></li><li><a href=https://www.sitepoint.com/paginating-real-time-data-cursor-based-pagination>Paginating Real-Time Data with Cursor Based Pagination</a></li><li><a href=http://www.scienjus.com/app-server-paging/>APP后端分页设计</a></li></ul><div class=blog-tags><a href=https://blog.isayme.org/tags/api/>api</a>&nbsp;</div></article></div><footer><div class=social-icons></div><div class=container><p class="credits copyright"><a href=https://blog.isayme.org/about></a>&nbsp;&copy;
2024
&nbsp;/&nbsp;
<a href=https://blog.isayme.org/>BLOG - ISAYME</a>
&nbsp;&ndash;&nbsp;
<em class="fas fa-moon" id=dark-mode-toggle></em></p><p class="credits theme-by">Powered By <a href=https://gohugo.io>Hugo</a>&nbsp;
Theme
<a href=https://github.com/matsuyoshi30/harbor>Harbor</a></p></div></footer></body></html>